
# Copyright (c) Ixia technologies 2011-2012, Inc.

set releaseVersion 4.70
#===============================================================================
# Change made
# ==2011==
# Version 1.0 
#       1. Create
# Version 1.1
#       2. Release on June 12th
# Version 1.2
#		3. Release on June 14th 
# Version 1.3
# 		4. Release on June 15th
# Version 1.4
#		5. Release on June 28th
# Version 1.5
#		6. Release on June 30th
#		6.1	Add-in IxOperate package for compatibility
# Version 1.6
#		7. Release on July 21st
# Version 1.7
#		8. Release on July 28th
# Version 1.8
#		9. Release on Aug 4th
# Version 1.9
#		10. Release on Aug 7th
# Version 1.10
#		11. Release on Aug 9th
# Version 1.11
#		12. Release on Aug 9th
# Version 1.12
#		13. Release on Aug 10th
# Version 1.13
#		14. Release on Aug 18th
# Version 1.14
#		15. Release on Aug 25th
# Version 1.15
#		16. Release on Aug 26th
# version 1.16
#		17. Release on Aug 30th
# version 1.17
#		18. Release on Sep 1st
# Version 2.0
#		19. Add Ospf/bgp interface
#		19.1. Release on Sep 5th
# Version 2.1
#		20. Release on Sep 20th
# Version 2.2
#		21. Release on Oct 20th
# Version 2.3
#		22. Release on Oct 24th
# Version 2.4
#		23. Release on Nov 3rd
# Version 2.5
#		24. Multiuser login 
#		24.1. Release on Nov 21st
# Version 2.6
#		25. Release on Nov 28th
# Version 2.7
#		26. Release on Nov 30th
# Version 2.8
#		27. Release on Dec 28th
# Version 2.9
#		28. Release on Dec 30th
# ==2012==
# Version 2.10
#		29. Release on Jan 5th
# Version 2.11
#		30. Release on Jan 12th
# Version 2.12
#		31. Release on Jan 13th
# Version 2.13
#		32. Release on Jan 14th
# Version 2.14
#		33. Release on Jan 18th
# Version 2.15
#		34. Release on Jan 20th
# Version 2.16
#		35. Release on Feb 15th
# Version 2.17
#		36. Release on Feb 28th
# Version 2.18
#		37. Release on Mar 20th
# Version 2.19
#		38. Release on Mar 30th
# Version 2.20
#		39. Release on Apr 17th
# Version 2.21
#		40. Release on Apr 18th
# Version 2.23
# 		41. Release on May 5th
# Version 2.24
#		42. Release on May 22nd
# Version 2.25
#		43. Release on June 5th
# Version 3.1
#		44. Add Rfc2544/Trill/DCBX/FC/FCoE interface 
#		44.1 Release on June 17th
# Version 3.2
#		45. Add DCBX Qaz TLV
#		45.1 Release on June 26th
# Version 3.3
#		46. Release on June 28th
# Version 3.5
#		47. Release on July 5th
# Version 3.6
#		48. Release on July 10th
# Version 3.7
#		49. Release on July 11th
# Version 3.8
#		50. Release on July 17th
# Version 3.9
#		51. Release on July 18th
# Version 3.10
# 		52. Release on July 24th
# Version 4.0
#		53. Release on July 30th
# Version 4.1
#		54. Release on Aug 2nd
# Version 4.2
#       55. Release on Aug 17th
# Version 4.3
#		56. Release on Aug 17th
# Version 4.4
#		57. Release on Aug 22th
# Version 4.5
#		58. Release on Aug 24th
# Version 4.6
#		59. Release on Sep 10th
# Version 4.7
#		60. Release on Sep 12th
#		60.1 include rfc2544
# Version 4.8
#		62. Release on Sep 24th
# Version 4.9
#		63. Release on Oct 8th
#       63.1 Include Ospfv3/PIM/RIP
# Version 4.10
#		64. Release on Oct 15th
# Version 4.11
#		65. Release on Oct 22nd
# Version 4.12
#		66. Release on Nov 1st
# Version 4.13
#		67. Release on Nov 7th
# Version 4.14
#		68. Release on Nov 9th
# Version 4.15
#		69. Release on Nov 17th
# Version 4.16
#		70. Release on Nov 19th
# Version 4.17
#		71. Release on Nov 26th
# Version 4.18
#		72. Release on Nov 29th
# Version 4.19
#		73. Fix Tcl Proxy reconnection defect
#		73.1 Release on Dec 12nd
# Version 4.20
#		74. Release on Dec 27th
# ==2013==
# Version 4.21
#		75. Release on Jan 10th
# Version 4.22
#		76. Release on Jan 18th
# Version 4.23
#		77. Release on Feb 7th
# Version 4.24
#		78. Release on Feb 22th
# Version 4.25
#       79. Add log file ixlogfile
#		79.1 Release on Mar 15th
# Version 4.26
#       80. Add force option in proc Login
#       80.1 Release on Mar 29th
# Version 4.27
#       81. Change log file direction to c:/windows/temp/ixlogfile
#       81.1 Release on Apr 12th
# Version 4.28
#       82. Release on Apr 19th
# Version 4.29
#       83. Release on May 8th
# Version 4.30
#       84. Release on Jun 21th
# Version 4.31
#       85. Release on Nov 7th
# Version 4.31patch
#		86. Release on Nov 24th
# ==2014==
# Version 4.32
#       87. Add proc loadconfig, modify Login 
#       87.1 source Ixia_NetDot1xRate.tcl
#       87.2 Release on Mar 19th
# Version 4.34
#		88. Release on June 6th
# Version 4.35
#		89. Release on June 7th
# Version 4.36
#		90. Release on June 10th
# Version 4.37
#		91. Release on June 10th
# Version 4.38
#		92. Release on June 11th
# Version 4.39
#		93. Release on June 11th
# Version 4.40
#		94. Release on June 11th
# Version 4.41
#		95. Release on June 12th
# Version 4.42
#		96. Release on June 12th
# Version 4.43
#		97. Release on June 13th
# Version 4.44
#		98. Release on June 16th
# Version 4.45
# 		99. Release on June 24th
# Version 4.46
#		100. Release on June 30th
# Version 4.47
#		101. Release on July 1st
# Version 4.48
#		102. Release on July 3rd
# Version 4.49
#		103. Release on July 7th
# Version 4.50
#		104. Release on July 9th
# Version 4.51
#		105. Release on July 15th
# Version 4.52
#		106. Release on July 16th
# Version 4.53
#		107. Release on July 19th
# Version 4.54
#		108. Release on July 26th
# Version 4.55
#		109. Release on July 29th
# Version 4.56
#		110. Release on Aug 22nd
# Version 4.57
#		111. Release on Aug 31st
# Version 4.58
#		112. Release on Sep 1st
# Version 4.59
#		113. Release on Sep 7th
# Version 4.60
#		114. Release on Sep 16th
# Version 4.61
#		115. Release on Oct 11th
# Version 4.62
#		116. Add compatibility to tbc file source
#		117. Release on Oct 16th
# Version 4.63
#		118. Release on Dec 9th
#       119. change server serverPort to remote_server remote_serverPort 
# 2015
# Version 4.64
#       120. Release on Jan 8th
# Version 4.65
#		121. Add support for NGPF
# Version 4.66
#		122. Release on May 14th
# Version 4.66
#		123. Add SearchMinFrameSizeByLoad on July 11th
# Version 4.67
#		124. Release on Aug. 28th
# Version 4.68
#       125. Add Rfc3918 JoinLeaveDelay
# Version 4.70
#       125. loadconfig for HW ruby.No objects automatic generated.

proc GetEnvTcl { product } {
   
   set productKey     "HKEY_LOCAL_MACHINE\\SOFTWARE\\Ixia Communications\\$product"
   set versionKey     [ registry keys $productKey ]
   set latestKey      [ lindex $versionKey end ]

    if { $latestKey == "Multiversion" } {
        set latestKey   [ lindex $versionKey [ expr [ llength $versionKey ] - 2 ] ]
        if { $latestKey == "InstallInfo" } {
            set latestKey   [ lindex $versionKey [ expr [ llength $versionKey ] - 3 ] ]
        }
    } elseif { $latestKey == "InstallInfo" } {
        set latestKey   [ lindex $versionKey [ expr [ llength $versionKey ] - 2 ] ]
    }
   set installInfo    [ append productKey \\ $latestKey \\ InstallInfo ]            
   return             [ registry get $installInfo  HOMEDIR ]

}
set testerConfigFile ""
set portlist [list]
set trafficlist [list]
set portnamelist [list]
set trafficnamelist [list]
set tportlist [list]
set remote_server "localhost"
set remote_serverPort "8009"
set LoadConfigMode 0
proc loadconfig { filename } {
    global portlist
    global trafficlist
    global portnamelist
    global trafficnamelist
    global tportlist
    global LoadConfigMode
    puts "Loadconfig $filename"
    ixNet exec loadConfig [ixNet readFrom $filename]
    set root [ixNet getRoot]
    set portlist [ixNet getL $root vport]
    foreach portobj $portlist {
        lappend portnamelist [ixNet getA $portobj -name]
    }
    
    set trafficlist [ixNet getL [ixNet getL $root traffic] trafficItem]
    foreach trafficItemobj $trafficlist {
	    lappend trafficnamelist [ixNet getA $trafficItemobj -name]
		set itemlist [lindex [ixNet getL $trafficItemobj highLevelStream] 0]
		lappend tportlist [ixNet getA $itemlist -txPortName]
        # set itemlist [ixNet getL $trafficItemobj highLevelStream]
        # foreach trafficobj $itemlist {
            # lappend trafficnamelist [ixNet getA $trafficobj -name]
            # lappend tportlist [ixNet getA $trafficobj -txPortName]
        # }
    }
    set LoadConfigMode 1
}

proc initLoadObjects {} {
    global portnamelist
    global portlist
    global trafficlist
    global tportlist
    global trafficnamelist
    
    foreach pname $portnamelist pobj $portlist {
        Port $pname NULL NULL $pobj
        # Generate protocols objects
        GenerateProtocolsObjects $pname
    }
    
    foreach tname $trafficnamelist tobj $trafficlist tport $tportlist {
        Traffic $tname $tport $tobj
    }
    
    
}

proc GenerateProtocolsObjects { portObj } {
    set tag "body Port::gen_pro_objs [info script]"
    Deputs "----- TAG: $tag -----"
    
    set portObj [GetObject $portObj]
    set handle [$portObj cget -handle]
    set handleName [$portObj cget -handleName]
    set protocols [ixNet getL $handle protocols]
    set protocolList [list bfd bgp igmp isis ldp mld ospf ospfV3 static]
    foreach pro $protocolList {
        set protocol [ixNet getL $protocols $pro]
        # Special to handle static
        set enabled [ ixNet getA $protocol -enabled ]
        if { $pro == "static" && $enabled == "::ixNet::OK" } {
            set enabled true
        }
        if { $enabled } {
            switch -exact $pro {
                bfd {
                    set bfdR [ixNet getL $protocol router]
                    BfdSession ${handleName}/bfd $handleName $bfdR
                }
                bgp {
                    set bgpNR [ixNet getL $protocol neighborRange]
                    BgpSession ${handleName}/bgp $handleName $bgpNR
                }
                igmp {
                    set igmpH [ixNet getL $protocol host]
                    IgmpHost ${handleName}/igmp $handleName $igmpH
                }
                mld {
                    set mldH [ixNet getL $protocol host]
                    MldHost ${handleName}/mld $handleName $mldH
                }
                isis {
                    set isisR [ixNet getL $protocol router]
                    IsisSession ${handleName}/isis $handleName $isisR
                }
                ldp {
                    set ldpR [ixNet getL $protocol router]
                    LdpSession ${handleName}/ldp $handleName $ldpR
                }
                ospf {
                    set ospfR [ixNet getL $protocol router]
                    Ospfv2Session ${handleName}/ospf $handleName $ospfR
                }
                ospfV3 {
                    set ospfV3R [ixNet getL $protocol router]
                    Ospfv3Session ${handleName}/ospfV3 $handleName $ospfV3R
                }
                static {
                    set staticLan [ixNet getL $protocol lan]
                    Host ${handleName}/static $handleName $staticLan
                }
            }
        }
    }

    set protocolStack [ixNet getL $handle protocolStack]
    set protocolStackList [list ipEndpoint dhcpEndpoint dhcpServerEndpoint pppoxEndpoint]
    foreach proStack $protocolStackList {
        set ethernet [ixNet getL $protocolStack ethernet]
        if { [llength $ethernet] == 0 } {
            continue
        }
		
		foreach ethernet $ethernet {
			set stack [ixNet getL $ethernet $proStack]
			if { $stack != "" } {
				switch -exact $proStack {
					dhcpEndpoint {
						set ranges [ixNet getL $stack range]
						foreach range $ranges {
							set ipType [ixNet getA $range/dhcpRange -ipType]
							set objName [ixNet getA $range/dhcpRange -name]
							if { $ipType == "IPv4" } {
								Dhcpv4Host $objName $handleName $stack $range
							} elseif { $ipType == "IPv6" } {
								Dhcpv6Host $objName $handleName $stack $range
							}
						}
					}
					dhcpServerEndpoint {
						set ranges [ixNet getL $stack range]
						foreach range $ranges {
							set ipType [ixNet getA $range/dhcpServerRange -ipType]
							set objName [ixNet getA $range/dhcpServerRange -name]
							if { $ipType == "IPv4" } {
								Dhcpv4Server $objName $handleName $stack $range
							} elseif { $ipType == "IPv6" } {
								Dhcpv6Server $objName $handleName $stack $range
							}
						}
					}
					pppoxEndpoint {
						set ranges [ixNet getL $stack range]
						foreach range $ranges {
							set objName [ixNet getA $range/pppoxRange -name]
							PppoeHost $objName $handleName $stack $range
						}
					}
					ipEndpoint {
						set ranges [ixNet getL $stack range]
						foreach range $ranges {
							set objName [ixNet getA $range/ipRange -name]
							set ipRangeOptions [ixNet getL $protocolStack ipRangeOptions]
							if { [llength $ipRangeOptions] != 0 } {
								if { [ixNet getA $ipRangeOptions -ipv6AddressMode] == "autoconf" } {
									Ipv6AutoConfigHost $objName $handleName $stack $range
								} else {
									IPoEHost $objName $handleName $stack $range
								}
							}
						}
					}
				}
			}
		}
    }
}


proc GetAllPortObj {} {
    set portObj [list]
    set objList [ find objects ]
    foreach obj $objList {
        if { [ $obj isa Port ] } {
            lappend portObj [ $obj cget -handle ]
        }
    }
    
    return $portObj
}

proc GetValidHandleObj { objType handle { parentHnd "" } } {
set tag "GetValidHandleObj [info script]"
    Deputs "----- TAG: $tag -----"
	set index 0
	if { [ catch {
		set index [expr $index + $handle] 
	} err ] } {
		set index 0
	}
	
	switch -exact $objType {
		port {
        Deputs "check port: checkname $handle"
			foreach port [ixNet getL [ixNet getRoot] vport] {
                set portname [ixNet getA $port -name]
				if { $port == $handle } {
					return $handle
				} elseif { $portname == $handle || $portname == [lindex [split $handle "::"] end] } {
                Deputs "portname:$portname; checkname $handle"
					return $port 
				} elseif { [llength [ split $handle "/" ]] == 3 } {
					set realLocationInfo [ split $handle "/" ]
					set assignedTo [ixNet getA $port -assignedTo]
					set ModuleNo    [lindex [split $assignedTo ":"] 1]
					set PortNo      [lindex [split $assignedTo ":"] 2]
					if { $ModuleNo == [lindex $realLocationInfo 1] && $PortNo == [lindex $realLocationInfo 2]} {
						return $port
					}
				}
			}
			return ""
		}
		traffic {
			set trafficObjs [ixNet getL [ixNet getL [ixNet getRoot] traffic] trafficItem]
			foreach trafficItemobj $trafficObjs {
				set itemlist [ixNet getL $trafficItemobj highLevelStream]
                set itemName [ixNet getA $trafficItemobj -name]
				foreach trafficobj $itemlist {
                    set highName [ixNet getA $trafficobj -name]
					if { $highName == $handle || [string range $handle 1 [expr [string length $handle] - 2]] == $highName } {
						return $trafficItemobj
					} elseif { $itemName == $handle || [string range $handle 1 [expr [string length $handle] - 2]] == $itemName || $itemName == [lindex [split $handle "::"] end] } {
						return $trafficItemobj
					}
                    # if { [ixNet getA $trafficobj -txPortName] == [ixNet getA $parentHnd -name] } {
                        # if { $highName == $handle || [string range $handle 1 [expr [string length $handle] - 2]] == $highName } {
                            # return $trafficItemobj
                        # } elseif { $itemName == $handle || [string range $handle 1 [expr [string length $handle] - 2]] == $itemName || $itemName == [lindex [split $handle "::"] end] } {
                            # return $trafficItemobj
                        # }
                    # }
				}
			}
            
            set index [expr $index - 1]
            if { $index >= 0 && [llength $trafficObjs] != 0 && [llength $trafficObjs] > $index } {
                return [lindex $trafficObjs $index]
            }
            
            return ""
		}
		bfd {
			set protocols [ixNet getL $parentHnd protocols]
			set protocol [ixNet getL $protocols bfd]
			if { [ ixNet getA $protocol -enabled ] } {
				set routers [ixNet getL $protocol router]
				foreach router $routers {
					if { $router == $handle } {
						return $handle
					} 
				}
				
				set index [expr $index - 1]
				if { $index >= 0 && [llength $routers] > $index} {
					return [lindex $routers $index]
				}
			}
			return ""
		}

		bgp {
			set protocols [ixNet getL $parentHnd protocols]
			set protocol [ixNet getL $protocols bgp]
			if { [ ixNet getA $protocol -enabled ] } {
				set routers [ixNet getL $protocol neighborRange]
				foreach router $routers {
					if { $router == $handle } {
						return $handle
					} 
				}
				
				set index [expr $index - 1]
				if { $index >= 0 && [llength $routers] != 0 && [llength $routers] > $index } {         
					return [lindex $routers $index]
				}
			}			
			return ""
		}
		igmp_host {
			set protocols [ixNet getL $parentHnd protocols]
			set protocol [ixNet getL $protocols igmp]
			if { [ ixNet getA $protocol -enabled ] } {
				set hosts [ixNet getL $protocol host]
				foreach host $hosts {
					if { $host == $handle } {
						return $handle
					} 
				}
				
				set index [expr $index - 1]
				if { $index >= 0 && [llength $hosts] != 0 && [llength $hosts] > $index } {
					return [lindex $hosts $index]
				}
			}			
			return ""
		}
		mld_host {
			set protocols [ixNet getL $parentHnd protocols]
			set protocol [ixNet getL $protocols mld]
			if { [ ixNet getA $protocol -enabled ] } {
				set hosts [ixNet getL $protocol host]
				foreach host $hosts {
					if { $host == $handle } {
						return $handle
					} 
				}
				
				set index [expr $index - 1]
				if { $index >= 0 && [llength $hosts] != 0 && [llength $hosts] > $index } {
					return [lindex $hosts $index]
				}
			}			
			return ""		
		}
		isis {
			set protocols [ixNet getL $parentHnd protocols]
			set protocol [ixNet getL $protocols isis]
			if { [ ixNet getA $protocol -enabled ] } {
				set routers [ixNet getL $protocol router]
				foreach router $routers {
					if { $router == $handle } {
						return $handle
					} 
				}
				
				set index [expr $index - 1]
				if { $index >= 0 && [llength $routers] > $index} {
					return [lindex $routers $index]
				}
			}			
			return ""		
		}
		ldp {
			set protocols [ixNet getL $parentHnd protocols]
			set protocol [ixNet getL $protocols ldp]
			if { [ ixNet getA $protocol -enabled ] } {
				set routers [ixNet getL $protocol router]
				foreach router $routers {
					if { $router == $handle } {
						return $handle
					} 
				}
				
				set index [expr $index - 1]
				if { $index >= 0 && [llength $routers] > $index} {
					return [lindex $routers $index]
				}
			}			
			return ""		
		}
		ospfv2 {
			set protocols [ixNet getL $parentHnd protocols]
			set protocol [ixNet getL $protocols ospf]
			if { [ ixNet getA $protocol -enabled ] } {
				set routers [ixNet getL $protocol router]
				foreach router $routers {
					if { $router == $handle } {
						return $handle
					} 
				}
				
				set index [expr $index - 1]
				if { $index >= 0 && [llength $routers] > $index} {
					return [lindex $routers $index]
				}
			}			
			return ""		
		}
		ospfv3 {
			set protocols [ixNet getL $parentHnd protocols]
			set protocol [ixNet getL $protocols ospfV3]
			if { [ ixNet getA $protocol -enabled ] } {
				set routers [ixNet getL $protocol router]
				foreach router $routers {
					if { $router == $handle } {
						return $handle
					} 
				}
				
				set index [expr $index - 1]
				if { $index >= 0 && [llength $routers] > $index} {
					return [lindex $routers $index]
				}
			}			
			return ""		
		}
		host {
			set protocols [ixNet getL $parentHnd protocols]
			set protocol [ixNet getL $protocols static]
			if { [ ixNet getA $protocol -enabled ] == "::ixNet::OK" } {
				set lans [ixNet getL $protocol lan]
				foreach lan $lans {
					if { $lan == $handle } {
						return $handle
					} 
				}
				
				set index [expr $index - 1]
				if { $index >= 0 && [llength $lans] > $index} {
					return [lindex $lans $index]
				}
			}
			return ""			
		}
		dhcp {
			set protocolStack [ixNet getL $parentHnd protocolStack]
			set ethernets [ixNet getL $protocolStack ethernet]
			foreach ethernet $ethernets {
				set stack [ixNet getL $ethernet dhcpEndpoint]
				if { $stack == "" } {
					continue
				}
				set ranges [ixNet getL $stack range]
                set ipv4Ranges [list ]
				foreach range $ranges {
				    if { [ixNet getA $range/dhcpRange -ipType] != "IPv4" } {
						continue
					}
                    lappend ipv4Ranges $range
                    set rangeName [ixNet getA $range/dhcpRange -name]
					if { $range == $handle } {
						return [list $stack $range]
					} elseif { $rangeName == $handle || [string range $handle 1 [expr [string length $handle] - 2]] == $rangeName } {
						return [list $stack $range]
					}
				}
                set index [expr $index - 1]
                if { $index >= 0 && [llength $ipv4Ranges] > $index} {
                    return [list $stack [lindex $ipv4Ranges $index]]
                }
			}
			return ""
		}
		dhcp_server {
			set protocolStack [ixNet getL $parentHnd protocolStack]
			set ethernets [ixNet getL $protocolStack ethernet]
			foreach ethernet $ethernets {
				set stack [ixNet getL $ethernet dhcpServerEndpoint]
				if { $stack == "" } {
					continue
				}
				set ranges [ixNet getL $stack range]
                set ipv4Ranges [list ]
				foreach range $ranges {
				    if { [ixNet getA $range/dhcpServerRange -ipType] != "IPv4" } {
						continue
					}
                    lappend ipv4Ranges $range
                    set rangeName [ixNet getA $range/dhcpRange -name]
					if { $range == $handle } {
						return [list $stack $range]
					} elseif { $rangeName == $handle || [string range $handle 1 [expr [string length $handle] - 2]] == $rangeName } {
						return [list $stack $range]
					}	
				}
                set index [expr $index - 1]
                if { $index >= 0 && [llength $ipv4Ranges] > $index} {
                    return [list $stack [lindex $ipv4Ranges $index]]
                }
			}
			return ""
		}
		dhcpv6 {
			set protocolStack [ixNet getL $parentHnd protocolStack]
			set ethernets [ixNet getL $protocolStack ethernet]
			foreach ethernet $ethernets {
				set stack [ixNet getL $ethernet dhcpEndpoint]
				if { $stack == "" } {
					continue
				}
				set ranges [ixNet getL $stack range]
                set ipv6Ranges [list ]
				foreach range $ranges {
				    if { [ixNet getA $range/dhcpRange -ipType] != "IPv6" } {
						continue
					}
                    lappend ipv6Ranges $range
                    set rangeName [ixNet getA $range/dhcpRange -name]
					if { $range == $handle } {
						return [list $stack $range]
					} elseif { $rangeName == $handle || [string range $handle 1 [expr [string length $handle] - 2]] == $rangeName } {
						return [list $stack $range]
					}
				}
                set index [expr $index - 1]
                if { $index >= 0 && [llength $ipv6Ranges] > $index} {
                    return [list $stack [lindex $ipv6Ranges $index]]
                }	
			}
			return ""
		}
		dhcpv6_server {
			set protocolStack [ixNet getL $parentHnd protocolStack]
			set ethernets [ixNet getL $protocolStack ethernet]
			foreach ethernet $ethernets {
				set stack [ixNet getL $ethernet dhcpServerEndpoint]
				if { $stack == "" } {
					continue
				}
				set ranges [ixNet getL $stack range]
                set ipv6Ranges [list ]
				foreach range $ranges {
				    if { [ixNet getA $range/dhcpServerRange -ipType] != "IPv6" } {
						continue
					}
                    lappend ipv6Ranges $range
                    set rangeName [ixNet getA $range/dhcpRange -name]
					if { $range == $handle } {
						return [list $stack $range]
					} elseif { $rangeName == $handle || [string range $handle 1 [expr [string length $handle] - 2]] == $rangeName } {
						return [list $stack $range]
					}
				}
                set index [expr $index - 1]
                if { $index >= 0 && [llength $ipv6Ranges] > $index} {
                    return [list $stack [lindex $ipv6Ranges $index]]
                }
			}
			return ""
		}		
		pppoe_host {
			set protocolStack [ixNet getL $parentHnd protocolStack]
			set ethernets [ixNet getL $protocolStack ethernet]
			foreach ethernet $ethernets {
				set stack [ixNet getL $ethernet pppoxEndpoint]
				if { $stack == "" } {
					continue
				}
				set ranges [ixNet getL $stack range]
				foreach range $ranges {
                    set rangeName [ixNet getA $range/pppoxRange -name]
					if { $range == $handle } {
						return [list $stack $range]
					} elseif { $rangeName == $handle || [string range $handle 1 [expr [string length $handle] - 2]] == $rangeName } {
						return [list $stack $range]
					}
				}
                set index [expr $index - 1]
                if { $index >= 0 && [llength $ranges] > $index} {
                    return [list $stack [lindex $ranges $index]]
                }
			}
			return ""
		}
        ipoe_host {
			set protocolStack [ixNet getL $parentHnd protocolStack]
            set ipRangeOptions [ixNet getL $protocolStack ipRangeOptions]
			set ethernets [ixNet getL $protocolStack ethernet]
			foreach ethernet $ethernets {
				set stack [ixNet getL $ethernet ipEndpoint]
				if { $stack == "" } {
					continue
				}
				set ranges [ixNet getL $stack range]
                set ipoeRanges [list ]
				foreach range $ranges {
                    if { [llength $ipRangeOptions] != 0 } {
                        if { [ixNet getA $ipRangeOptions -ipv6AddressMode] == "autoconf" } {
                            continue
                        }
                    }
                    lappend ipoeRanges $range
                    set rangeName [ixNet getA $range/ipRange -name]
                    if { $range == $handle } {
                        return [list $stack $range]
                    } elseif { $rangeName == $handle || [string range $handle 1 [expr [string length $handle] - 2]] == $rangeName } {
                        return [list $stack $range]
                    }
				}
                set index [expr $index - 1]
                if { $index >= 0 && [llength $ipoeRanges] > $index} {
                    return [list $stack [lindex $ipoeRanges $index]]
                }
			}
			return ""
        }
        default {
            return ""
        }
	}
    return ""
}

proc Login { { location "localhost/8009"} { force 0 } { filename null } } {
	global ixN_tcl_v
	global loginInfo
    
    global portlist
    global trafficlist
    global portnamelist
    global trafficnamelist
    global tportlist
    global testerConfigFile
    
	global remote_server
	global remote_serverPort
	
    puts "testerConfigFile:$testerConfigFile"
	set loginInfo $location
    puts "Login...$location"	
	if { $location == "" } {
		set port "localhost/8009"
	} else {
		set port $location
	}

	set portInfo [ split $port "/" ]
	set remote_server	 [ lindex $portInfo 0 ]
	if { [ regexp {\d+\.\d+\.\d+\.\d+} $remote_server ] || ( $remote_server == "localhost" ) } {
		set portInfo [ lreplace $portInfo 0 0 ]
	} else {
		set remote_server localhost
	}
	if { [ llength $portInfo ] == 0 } {
		set portInfo 8009
	}
    
    set flag 0
	foreach port $portInfo {
		ixNet disconnect
		ixNet connect $remote_server -version $ixN_tcl_v -port $port
		set root [ ixNet getRoot]
		if { $force } {
			puts "Login successfully on port $port."
			#return	
			set remote_serverPort $port
            set flag 1            
		} else {
			if { [ llength [ ixNet getL $root vport ] ] > 0 } {
				puts "The connecting optional port $port is ocuppied, try next port..."
				continue
			} else {
				puts "Login successfully on port $port."
				#return
				set remote_serverPort $port
                set flag 1
			}
		}
        
        if { $flag == 1 } {
            if { $filename != "null"  || $testerConfigFile != "" } {
                if { $filename != "null" } {
                    loadconfig $filename
                } else {
                    loadconfig $testerConfigFile 
                }
                
				after 15000
                
				
				return
                
            } else {
                ixNet exec newConfig
                return
            }
        }
	}
	puts "Login failed on all port $portInfo."
	return
}

proc GetAllPortObj {} {

	set portObj [list]
	set objList [ find objects ]
	foreach obj $objList {
		if { [ $obj isa Port ] } {
			lappend portObj [ $obj cget -handle ]
		}
	}
	return $portObj
}

proc SearchMinFrameSizeByLoad { args } {
    set tag "proc SearchMinFrameSizeByLoad [info script]"
	Deputs "----- TAG: $tag -----"
    Deputs "Args:$args "
    
    array set frame_load [list ]
    set upstreams [list]
    set streams [list]
    set downstreams [list]
    set duration [ expr 60 * 1000 ]
	set percentage 99.98
    set inflation 0
    set all_streams [list ]
	foreach { key value } $args {
        set key [string tolower $key]
        switch -exact -- $key {
            -frame_len {
                set frame_size_list $value
            }
            -inflation {
                set inflation $value
            }
            -upstreams {
                foreach stream $value {
                    lappend all_streams $stream
                    lappend upstreams [ $stream cget -handle ]
                }
            }
            -downstreams {
                foreach stream $value {
                    lappend all_streams $stream
                    lappend downstreams [ $stream cget -handle ]
                }	            
            }
            -streams {
                foreach stream $value {
                    lappend all_streams $stream
                    lappend streams [ $stream cget -handle ]
                }	
            }
            -duration {
                set duration [ expr 1000 * $value ]
            }
            -resultfile {
                set resultfile $value
            }
			-percentage {
				set percentage $value
             }
        }
    }
    Deputs "Input streams: $all_streams"
    # According to inflation to calculate traffic load
    foreach frame_size $frame_size_list {
        set frame_load($frame_size) [expr (($frame_size + 20) * 1.0 / ($frame_size + 20 + $inflation)) * 100]
        Deputs "Frame size: $frame_size, traffic load: $frame_load($frame_size)"
    }  
    
    set index 0
    set min_index 0
    set max_index [ expr [ llength $frame_size_list ] - 1 ]
    set qulified_index ""
	set iteration 1
	set iterationResult false
    set isRunning false	
    while { 1 } {
        if { $qulified_index == $index } {
            # Don't need to run same fram size twice
            break   
        }
        
        set frame_size [ lindex $frame_size_list $index ]
        
        if { [llength $streams ] > 0 } {
            foreach stream $streams {
                set highLevelStream [ ixNet getL $stream configElement ]
                set frameSize [ ixNet getL $highLevelStream frameSize ]
                ixNet setA $frameSize -fixedSize $frame_size
                ixNet commit 
                set frameRate [ ixNet getL $highLevelStream frameRate ]
                
                ixNet setM $frameRate -rate $frame_load($frame_size) -type percentLineRate
                ixNet commit
            }
        } else {
            set root [ixNet getRoot]
            set traffic [ixNet getL $root traffic]
            foreach trafficItem [ixNet getL $traffic trafficItem] {
                set highLevelStream [ ixNet getL $trafficItem configElement ]
                set frameSize [ ixNet getL $highLevelStream frameSize ]
                ixNet setA $frameSize -fixedSize $frame_size
                ixNet commit 
                set frameRate [ ixNet getL $highLevelStream frameRate ]
                set endpointSet [ ixNet getL $trafficItem endpointSet ]
                set src [ ixNet getA $endpointSet -sources ]
                
                ixNet setM $frameRate -rate $frame_load($frame_size) -type percentLineRate
                ixNet commit
                
                foreach upstream $upstreams {
                    if { $upstream == [ string range $src 0 [ expr [ string length $upstream ] - 1 ] ] ||
                         $src == [ string range $upstream 0 [ expr [ string length $src ] - 1 ] ] } {
                        ixNet setM $frameRate -rate 100 -type percentLineRate
                        ixNet setA $frameSize -fixedSize [ expr $frame_size + $inflation ]
                        ixNet commit
                    } elseif { $upstream == $trafficItem } {
                       ixNet setM $frameRate -rate 100 -type percentLineRate
                        ixNet setA $frameSize -fixedSize [ expr $frame_size + $inflation ]
                        ixNet commit
                    }
                }
            }
        }
        ixNet commit
        Tester::apply_traffic
		
        if { [ catch {
            foreach traffic $all_streams {
                #ixNet exec startStatelessTraffic $traffic
                $traffic start
            }
            #Tester::start_traffic
            after $duration
            foreach traffic $all_streams {
                #ixNet exec stopStatelessTraffic $traffic
                $traffic stop
            }
            #Tester::stop_traffic
            after [expr 10 * 1000]
        } err ] } {
            Deputs "Failed to start/stop traffic"
            break
        }
        
        if { [ Tester::isLossFrames $all_streams] } {
            set iterationResult false
        } else {
            set iterationResult true
        }
        if { !$isRunning } {
            Tester::saveResults -resultfile $resultfile -frame_size $frame_size -streams $all_streams
        } else {
            Tester::saveResults -resultfile $resultfile -frame_size $frame_size -streams $all_streams -append true
        }
        set isRunning true
        if { !$iterationResult } {
            # Failed
            set min_index $index
            #Tester::saveResults -resultfile $resultfile -frame_size $frame_size
            # Reached to minmum frame size 
            if { $min_index == $max_index} {
                Deputs "Iteration #$iteration - Frame Size(Bytes): $frame_size, Min Frame Size: [ lindex $frame_size_list $min_index ], Max Frame Size: [ lindex $frame_size_list $max_index ], Iteration Result: $iterationResult"
                break
            }
        } else {
            # Passed
            set qulified_index $index
            set max_index $index
            Tester::saveResults -resultfile $resultfile -frame_size $frame_size -streams $all_streams -append true
            #Tester::saveResults -resultfile $resultfile -frame_size $frame_size -streams $all_streams
            # Reached to maximum frame size
            if { $min_index == $max_index} {
                Deputs "Iteration #$iteration - Frame Size(Bytes): $frame_size, Min Frame Size: [ lindex $frame_size_list $min_index ], Max Frame Size: [ lindex $frame_size_list $max_index ], Iteration Result: $iterationResult"
                break
            }
        }

        Deputs "Iteration #$iteration - Frame Size(Bytes): $frame_size, Min Frame Size: [ lindex $frame_size_list $min_index ], Max Frame Size: [ lindex $frame_size_list $max_index ], Iteration Result: $iterationResult"
        incr iteration
        
        set index [ expr ($min_index + $max_index) / 2 ]
        if { $index == $min_index } {
            incr index
            
            if { $index > $max_index } {
                set index $max_index
            }
        }
    }
    
    set ret [ GetStandardReturnHeader ]
    if { $qulified_index != "" } {
        set ret $ret[ GetStandardReturnBody "frame_size" [ lindex $frame_size_list $qulified_index ] ]
    } else {
        set ret $ret[ GetStandardReturnBody "frame_size" 0 ]
    }
    
    return $ret
}

proc RunCustomizeSizeByLoad { args } {
    set tag "proc RunCustomizeSizeByLoad [info script]"
	Deputs "----- TAG: $tag -----"
    Deputs "Args:$args "
    
    array set frame_load [list ]
    set upstreams [list]
    set streams [list]
    set downstreams [list]
    set duration [ expr 60 * 1000 ]
	set percentage 100
    set inflation 0
    set all_streams [list ]
	foreach { key value } $args {
        set key [string tolower $key]
        switch -exact -- $key {
            -frame_len {
                set frame_size_list $value
            }
            -inflation {
                set inflation $value
            }
            -upstreams {
                foreach stream $value {
                    lappend all_streams $stream
                    lappend upstreams [ $stream cget -handle ]
                }
            }
            -downstreams {
                foreach stream $value {
                    lappend all_streams $stream
                    lappend downstreams [ $stream cget -handle ]
                }	            
            }
            -streams {
                foreach stream $value {
                    lappend all_streams $stream
                    lappend streams [ $stream cget -handle ]
                }	
            }
            -duration {
                set duration [ expr 1000 * $value ]
            }
            -resultfile {
                set resultfile $value
            }
			-percentage {
				set percentage $value
             }
        }
    }
    Deputs "Input streams: $all_streams"
    # According to inflation to calculate traffic load
    foreach frame_size $frame_size_list {
        set frame_load($frame_size) [expr (($frame_size + 20) * 1.0 / ($frame_size + 20 + $inflation)) * $percentage]
        Deputs "Frame size: $frame_size, traffic load: $frame_load($frame_size)"
    }  
    
    set isRunning false	
    foreach frame_size $frame_size_list {
        if { [llength $streams ] > 0 } {
            foreach stream $streams {
                set highLevelStream [ ixNet getL $stream configElement ]
                set frameSize [ ixNet getL $highLevelStream frameSize ]
                ixNet setA $frameSize -fixedSize $frame_size
                ixNet commit 
                set frameRate [ ixNet getL $highLevelStream frameRate ]
                
                ixNet setM $frameRate -rate $frame_load($frame_size) -type percentLineRate
                ixNet commit
            }
        } else {
            set root [ixNet getRoot]
            set traffic [ixNet getL $root traffic]
            foreach trafficItem [ixNet getL $traffic trafficItem] {
                set highLevelStream [ ixNet getL $trafficItem configElement ]
                set frameSize [ ixNet getL $highLevelStream frameSize ]
                ixNet setA $frameSize -fixedSize $frame_size
                ixNet commit 
                set frameRate [ ixNet getL $highLevelStream frameRate ]
                set endpointSet [ ixNet getL $trafficItem endpointSet ]
                set src [ ixNet getA $endpointSet -sources ]
                
                ixNet setM $frameRate -rate $frame_load($frame_size) -type percentLineRate
                ixNet commit
                
                foreach upstream $upstreams {
                    if { $upstream == [ string range $src 0 [ expr [ string length $upstream ] - 1 ] ] ||
                         $src == [ string range $upstream 0 [ expr [ string length $src ] - 1 ] ] } {
                        ixNet setM $frameRate -rate 100 -type percentLineRate
                        ixNet setA $frameSize -fixedSize [ expr $frame_size + $inflation ]
                        ixNet commit
                    } elseif { $upstream == $trafficItem } {
                       ixNet setM $frameRate -rate 100 -type percentLineRate
                        ixNet setA $frameSize -fixedSize [ expr $frame_size + $inflation ]
                        ixNet commit
                    }
                }
            }
        }
        ixNet commit
        
        if { [ catch {
            foreach traffic $all_streams {
                #ixNet exec startStatelessTraffic $traffic
                $traffic start
            }
            #Tester::start_traffic
            after $duration
            foreach traffic $all_streams {
                #ixNet exec stopStatelessTraffic $traffic
                $traffic stop
            }
            after [expr 5 * 1000]
        } err ] } {
            Deputs "Failed to start/stop traffic"
            break
        }
        
        if { !$isRunning } {
            Tester::saveResults -resultfile $resultfile -frame_size $frame_size -streams $all_streams
        } else {
            Tester::saveResults -resultfile $resultfile -frame_size $frame_size -streams $all_streams -append true
        }
        set isRunning true
    }
    
    return [ GetStandardReturnHeader ]
}

set currDir [file dirname [info script]]
puts "Package Directory $currDir"
puts "load package Ixia_Util..."
if { [ catch {
	source [file join $currDir Ixia_Util.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_Util.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
} 
puts "load package Ixia_NetObj..."
if { [ catch {
	source [file join $currDir Ixia_NetObj.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetObj.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
} 
puts "load package Ixia_NetTester..."
if { [ catch {
	source [file join $currDir Ixia_NetTester.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetTester.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
} 
puts "load package Ixia_NetPort..."
if { [ catch {
	source [file join $currDir Ixia_NetPort.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetPort.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
} 
puts "load package Ixia_NetTraffic..."
if { [ catch {
	source [file join $currDir Ixia_NetTraffic.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetTraffic.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
}
puts "load package Ixia_NetFlow..."
if { [ catch {
	source [file join $currDir Ixia_NetFlow.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetFlow.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
} 
puts "load package Ixia_NetDhcp..."
if { [ catch {
	source [file join $currDir Ixia_NetDhcp.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetDhcp.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
}
puts "load package Ixia_NetDhcpPD..."
if { [ catch {
	source [file join $currDir Ixia_NetDhcpPD.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetDhcpPD.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
} 
puts "load package Ixia_NetIgmp..."
if { [ catch {
	source [file join $currDir Ixia_NetIgmp.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetIgmp.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
} 
puts "load package Ixia_NetCapture..."
if { [ catch {
	source [file join $currDir Ixia_NetCapture.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetCapture.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
} 
puts "load package Ixia_NetCaptureFilter..."
if { [ catch {
	source [file join $currDir Ixia_NetCaptureFilter.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetCaptureFilter.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
} 
puts "load package Ixia_NetOspf..."
if { [ catch {
	source [file join $currDir Ixia_NetOspf.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetOspf.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
}
puts "load package Ixia_NetL3Vpn6Vpe..." 
if { [ catch {
	source [file join $currDir Ixia_NetL3Vpn6Vpe.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetL3Vpn6Vpe.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
} 
puts "load package Ixia_NetLdp..."
if { [ catch {
	source [file join $currDir Ixia_NetLdp.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetLdp.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
} 
puts "load package Ixia_NetIsis..."
if { [ catch {
	source [file join $currDir Ixia_NetIsis.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetIsis.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
} 
puts "load package Ixia_NetTrill..."
if { [ catch {
	source [file join $currDir Ixia_NetTrill.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetTrill.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
} 
puts "load package Ixia_NetDcbx..."
if { [ catch {
	source [file join $currDir Ixia_NetDcbx.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetDcbx.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
} 
puts "load package Ixia_NetFcoe..."
if { [ catch {
	source [file join $currDir Ixia_NetFcoe.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetFcoe.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
} 
puts "load package Ixia_NetPPPoX..."
if { [ catch {
	source [file join $currDir Ixia_NetPPPoX.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetPPPoX.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
} 
puts "load package Ixia_NetBgp..."
if { [ catch {
	source [file join $currDir Ixia_NetBgp.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetBgp.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
} 
puts "load package Ixia_NetRfc2544..."
if { [ catch {
	source [file join $currDir Ixia_NetRFC2544.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetRFC2544.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
} 
puts "load package Ixia_NetRfc3918..."
if { [ catch {
	source [file join $currDir Ixia_NetRFC3918.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetRFC3918.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
}
puts "load package Ixia_NetDot1xRate..."
if { [ catch {
	source [file join $currDir Ixia_NetDot1xRate.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetDot1xRate.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
} 
puts "load package Ixia_NetRip..."
if { [ catch {
	source [file join $currDir Ixia_NetRip.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetRip.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
} 
puts "load package Ixia_NetPim...."
if { [ catch {
	source [file join $currDir Ixia_NetPim.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetPim.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
} 
puts "load package Ixia_NetBfd...."
if { [ catch {
	source [file join $currDir Ixia_NetBfd.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetBfd.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
} 
puts "load package Ixia_NetDeviceGroup...."
if { [ catch {
	source [file join $currDir Ixia_NetDeviceGroup.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetDeviceGroup.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
}

puts "load package Ixia_NetL2TP..."
if { [ catch {
	source [file join $currDir Ixia_NetL2TP.tcl]
} err ] } {
	if { [ catch {
			source [file join $currDir Ixia_NetL2TP.tbc]
	} tbcErr ] } {
		puts "load package fail...$err $tbcErr"
	}
} 

set errNumber(1)    "Bad argument value or out of range..."
set errNumber(2)    "Madatory argument missed..."
set errNumber(3)    "Unsupported parameter..."
set errNumber(4)    "Confilct argument..."
puts "set error message list..."

set ixN_tcl_v "6.0"
set ixN_lib ""
puts "connect to ixNetwork Tcl Server version $ixN_tcl_v"
if { $::tcl_platform(platform) == "windows" } {
	puts "windows platform..."
	package require registry

    if { [ catch {
        set ixN_lib "[ GetEnvTcl IxNetwork ]/TclScripts/lib/IxTclNetwork"
	    lappend auto_path  $ixN_lib
    } err ] } {
        set ixN_lib $currDir/IxNetwork
		lappend auto_path $ixN_lib
        puts "Failed to invoke IxNetwork environment...$err"
		puts "Try to load IxNetwork local lib..."
	}

    puts "load package IxTclNetwork..."
	package require IxTclNetwork
	puts "load package IxTclHal..."	
	catch {	
		source [ GetEnvTcl IxOS ]/TclScripts/bin/ixiawish.tcl
	}
	catch {package require IxTclHal}
}

package provide IxiaNet $releaseVersion
puts "package require success on version $releaseVersion"

# catch { console hide }

rename ixNet IxNet
proc ixNet { args } {
	DeputsCMD "ixNet $args"
	eval IxNet $args
}

set timeVal  [ clock format [ clock seconds ] -format %Y%m%d_%H_%M ]
set clickVal [ clock clicks ]
if { [file exist "c:/windows/temp/ixlogfile"] } {
	set logfile_name "c:/windows/temp/ixlogfile/$timeVal.txt"
} elseif { [file exist "c:/temp/ixlogfile"] } {
	set logfile_name "c:/temp/ixlogfile/$timeVal.txt"
} else {
	if { [ catch {
		file mkdir "c:/windows/temp/ixlogfile"
		set logfile_name "c:/windows/temp/ixlogfile/$timeVal.txt"
	} ] } {
		file mkdir "c:/temp/ixlogfile"
		set logfile_name "c:/temp/ixlogfile/$timeVal.txt"
	}
}
IxDebugOn
IxDebugCmdOn